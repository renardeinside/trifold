/**
 * Generated by orval v7.10.0 ðŸº
 * Do not edit manually.
 * Trifold | Full stack data application on Databricks
 * Trifold is a full stack data application on Databricks
 * OpenAPI spec version: 0.0.0+3552fce.20250806113526
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

export type ComplexValueDisplay = string | null;

export type ComplexValuePrimary = boolean | null;

export type ComplexValueRef = string | null;

export type ComplexValueType = string | null;

export type ComplexValueValue = string | null;

export interface ComplexValue {
  display?: ComplexValueDisplay;
  primary?: ComplexValuePrimary;
  ref?: ComplexValueRef;
  type?: ComplexValueType;
  value?: ComplexValueValue;
}

export interface DessertIn {
  name: string;
  price: number;
  description: string;
  leftInStock: number;
}

export interface DessertOut {
  id: number;
  name: string;
  price: number;
  description: string;
  leftInStock: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type NameFamilyName = string | null;

export type NameGivenName = string | null;

export interface Name {
  familyName?: NameFamilyName;
  givenName?: NameGivenName;
}

export interface ProfileView {
  user: User;
}

export type UserActive = boolean | null;

export type UserDisplayName = string | null;

export type UserEmails = ComplexValue[] | null;

export type UserEntitlements = ComplexValue[] | null;

export type UserExternalId = string | null;

export type UserGroups = ComplexValue[] | null;

export type UserId = string | null;

export type UserName = Name | null;

export type UserRoles = ComplexValue[] | null;

export type UserSchemas = UserSchema[] | null;

export type UserUserName = string | null;

export interface User {
  active?: UserActive;
  displayName?: UserDisplayName;
  emails?: UserEmails;
  entitlements?: UserEntitlements;
  externalId?: UserExternalId;
  groups?: UserGroups;
  id?: UserId;
  name?: UserName;
  roles?: UserRoles;
  schemas?: UserSchemas;
  userName?: UserUserName;
}

export type UserSchema = (typeof UserSchema)[keyof typeof UserSchema];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSchema = {
  "urn:ietf:params:scim:schemas:core:20:User":
    "urn:ietf:params:scim:schemas:core:2.0:User",
  "urn:ietf:params:scim:schemas:extension:workspace:20:User":
    "urn:ietf:params:scim:schemas:extension:workspace:2.0:User",
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * Model representing the version information of the package.
 */
export interface VersionView {
  version: string;
}

/**
 * @summary Version
 */
export type versionResponse200 = {
  data: VersionView;
  status: 200;
};

export type versionResponseComposite = versionResponse200;

export type versionResponse = versionResponseComposite & {
  headers: Headers;
};

export const getVersionUrl = () => {
  return `/api/version`;
};

export const version = async (
  options?: RequestInit,
): Promise<versionResponse> => {
  const res = await fetch(getVersionUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: versionResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as versionResponse;
};

export const getVersionQueryKey = () => {
  return [`/api/version`] as const;
};

export const getVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionQueryError = unknown;

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVersionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionSuspenseQueryError = unknown;

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Profile
 */
export type profileResponse200 = {
  data: ProfileView;
  status: 200;
};

export type profileResponseComposite = profileResponse200;

export type profileResponse = profileResponseComposite & {
  headers: Headers;
};

export const getProfileUrl = () => {
  return `/api/profile`;
};

export const profile = async (
  options?: RequestInit,
): Promise<profileResponse> => {
  const res = await fetch(getProfileUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: profileResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as profileResponse;
};

export const getProfileQueryKey = () => {
  return [`/api/profile`] as const;
};

export const getProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof profile>>> = ({
    signal,
  }) => profile({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof profile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof profile>>
>;
export type ProfileQueryError = unknown;

export function useProfile<
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof profile>>,
          TError,
          Awaited<ReturnType<typeof profile>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProfile<
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof profile>>,
          TError,
          Awaited<ReturnType<typeof profile>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProfile<
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Profile
 */

export function useProfile<
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getProfileQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getProfileSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof profile>>> = ({
    signal,
  }) => profile({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof profile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ProfileSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof profile>>
>;
export type ProfileSuspenseQueryError = unknown;

export function useProfileSuspense<
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof profile>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProfileSuspense<
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof profile>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProfileSuspense<
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof profile>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Profile
 */

export function useProfileSuspense<
  TData = Awaited<ReturnType<typeof profile>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof profile>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getProfileSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Desserts
 */
export type dessertsResponse200 = {
  data: DessertOut[];
  status: 200;
};

export type dessertsResponseComposite = dessertsResponse200;

export type dessertsResponse = dessertsResponseComposite & {
  headers: Headers;
};

export const getDessertsUrl = () => {
  return `/api/desserts`;
};

export const desserts = async (
  options?: RequestInit,
): Promise<dessertsResponse> => {
  const res = await fetch(getDessertsUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: dessertsResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as dessertsResponse;
};

export const getDessertsQueryKey = () => {
  return [`/api/desserts`] as const;
};

export const getDessertsQueryOptions = <
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof desserts>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDessertsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof desserts>>> = ({
    signal,
  }) => desserts({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof desserts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DessertsQueryResult = NonNullable<
  Awaited<ReturnType<typeof desserts>>
>;
export type DessertsQueryError = unknown;

export function useDesserts<
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof desserts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof desserts>>,
          TError,
          Awaited<ReturnType<typeof desserts>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDesserts<
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof desserts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof desserts>>,
          TError,
          Awaited<ReturnType<typeof desserts>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDesserts<
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof desserts>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Desserts
 */

export function useDesserts<
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof desserts>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDessertsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getDessertsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof desserts>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDessertsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof desserts>>> = ({
    signal,
  }) => desserts({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof desserts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DessertsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof desserts>>
>;
export type DessertsSuspenseQueryError = unknown;

export function useDessertsSuspense<
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof desserts>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDessertsSuspense<
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof desserts>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDessertsSuspense<
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof desserts>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Desserts
 */

export function useDessertsSuspense<
  TData = Awaited<ReturnType<typeof desserts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof desserts>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDessertsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create Dessert
 */
export type createDessertResponse200 = {
  data: DessertOut;
  status: 200;
};

export type createDessertResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type createDessertResponseComposite =
  | createDessertResponse200
  | createDessertResponse422;

export type createDessertResponse = createDessertResponseComposite & {
  headers: Headers;
};

export const getCreateDessertUrl = () => {
  return `/api/desserts`;
};

export const createDessert = async (
  dessertIn: DessertIn,
  options?: RequestInit,
): Promise<createDessertResponse> => {
  const res = await fetch(getCreateDessertUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(dessertIn),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: createDessertResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as createDessertResponse;
};

export const getCreateDessertMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDessert>>,
    TError,
    { data: DessertIn },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDessert>>,
  TError,
  { data: DessertIn },
  TContext
> => {
  const mutationKey = ["createDessert"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDessert>>,
    { data: DessertIn }
  > = (props) => {
    const { data } = props ?? {};

    return createDessert(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDessertMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDessert>>
>;
export type CreateDessertMutationBody = DessertIn;
export type CreateDessertMutationError = HTTPValidationError;

/**
 * @summary Create Dessert
 */
export const useCreateDessert = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDessert>>,
      TError,
      { data: DessertIn },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDessert>>,
  TError,
  { data: DessertIn },
  TContext
> => {
  const mutationOptions = getCreateDessertMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Update Dessert
 */
export type updateDessertResponse200 = {
  data: DessertOut;
  status: 200;
};

export type updateDessertResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updateDessertResponseComposite =
  | updateDessertResponse200
  | updateDessertResponse422;

export type updateDessertResponse = updateDessertResponseComposite & {
  headers: Headers;
};

export const getUpdateDessertUrl = (dessertId: number) => {
  return `/api/desserts/${dessertId}`;
};

export const updateDessert = async (
  dessertId: number,
  dessertIn: DessertIn,
  options?: RequestInit,
): Promise<updateDessertResponse> => {
  const res = await fetch(getUpdateDessertUrl(dessertId), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(dessertIn),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: updateDessertResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as updateDessertResponse;
};

export const getUpdateDessertMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDessert>>,
    TError,
    { dessertId: number; data: DessertIn },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDessert>>,
  TError,
  { dessertId: number; data: DessertIn },
  TContext
> => {
  const mutationKey = ["updateDessert"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDessert>>,
    { dessertId: number; data: DessertIn }
  > = (props) => {
    const { dessertId, data } = props ?? {};

    return updateDessert(dessertId, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDessertMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDessert>>
>;
export type UpdateDessertMutationBody = DessertIn;
export type UpdateDessertMutationError = HTTPValidationError;

/**
 * @summary Update Dessert
 */
export const useUpdateDessert = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDessert>>,
      TError,
      { dessertId: number; data: DessertIn },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateDessert>>,
  TError,
  { dessertId: number; data: DessertIn },
  TContext
> => {
  const mutationOptions = getUpdateDessertMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete Dessert
 */
export type deleteDessertResponse200 = {
  data: unknown;
  status: 200;
};

export type deleteDessertResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deleteDessertResponseComposite =
  | deleteDessertResponse200
  | deleteDessertResponse422;

export type deleteDessertResponse = deleteDessertResponseComposite & {
  headers: Headers;
};

export const getDeleteDessertUrl = (dessertId: number) => {
  return `/api/desserts/${dessertId}`;
};

export const deleteDessert = async (
  dessertId: number,
  options?: RequestInit,
): Promise<deleteDessertResponse> => {
  const res = await fetch(getDeleteDessertUrl(dessertId), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: deleteDessertResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as deleteDessertResponse;
};

export const getDeleteDessertMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDessert>>,
    TError,
    { dessertId: number },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteDessert>>,
  TError,
  { dessertId: number },
  TContext
> => {
  const mutationKey = ["deleteDessert"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDessert>>,
    { dessertId: number }
  > = (props) => {
    const { dessertId } = props ?? {};

    return deleteDessert(dessertId, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteDessertMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDessert>>
>;

export type DeleteDessertMutationError = HTTPValidationError;

/**
 * @summary Delete Dessert
 */
export const useDeleteDessert = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteDessert>>,
      TError,
      { dessertId: number },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteDessert>>,
  TError,
  { dessertId: number },
  TContext
> => {
  const mutationOptions = getDeleteDessertMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Server-Sent Events endpoint for real-time dessert updates.
 * @summary Desserts Events
 */
export type dessertsEventsResponse200 = {
  data: unknown;
  status: 200;
};

export type dessertsEventsResponseComposite = dessertsEventsResponse200;

export type dessertsEventsResponse = dessertsEventsResponseComposite & {
  headers: Headers;
};

export const getDessertsEventsUrl = () => {
  return `/api/desserts/events`;
};

export const dessertsEvents = async (
  options?: RequestInit,
): Promise<dessertsEventsResponse> => {
  const res = await fetch(getDessertsEventsUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: dessertsEventsResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as dessertsEventsResponse;
};

export const getDessertsEventsQueryKey = () => {
  return [`/api/desserts/events`] as const;
};

export const getDessertsEventsQueryOptions = <
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof dessertsEvents>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDessertsEventsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof dessertsEvents>>> = ({
    signal,
  }) => dessertsEvents({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dessertsEvents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DessertsEventsQueryResult = NonNullable<
  Awaited<ReturnType<typeof dessertsEvents>>
>;
export type DessertsEventsQueryError = unknown;

export function useDessertsEvents<
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dessertsEvents>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dessertsEvents>>,
          TError,
          Awaited<ReturnType<typeof dessertsEvents>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDessertsEvents<
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dessertsEvents>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dessertsEvents>>,
          TError,
          Awaited<ReturnType<typeof dessertsEvents>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDessertsEvents<
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dessertsEvents>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Desserts Events
 */

export function useDessertsEvents<
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dessertsEvents>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDessertsEventsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getDessertsEventsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof dessertsEvents>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDessertsEventsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof dessertsEvents>>> = ({
    signal,
  }) => dessertsEvents({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof dessertsEvents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DessertsEventsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof dessertsEvents>>
>;
export type DessertsEventsSuspenseQueryError = unknown;

export function useDessertsEventsSuspense<
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof dessertsEvents>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDessertsEventsSuspense<
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof dessertsEvents>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDessertsEventsSuspense<
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof dessertsEvents>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Desserts Events
 */

export function useDessertsEventsSuspense<
  TData = Awaited<ReturnType<typeof dessertsEvents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof dessertsEvents>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDessertsEventsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
