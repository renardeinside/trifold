# Cursor Agent Rules

## Project Structure
- This is a full-stack application with two main parts:
  - `src/<project-name>/ui/` - Frontend (React + Vite)
  - `src/<project-name>/` - Backend (FastAPI + Uvicorn)
- Backend serves both frontend and API routes at `/` and `/api` respectively
- Frontend client is auto-generated using `orval` command: `yarn --cwd src/<project-name>/ui orval`

## Package Management
- **Always use `yarn` for frontend package management** - never use `npm`
- **Always use `uv` for Python project management** - never use `pip` or other Python package managers
- UI code is located in the `/src/<project-name>/ui` folder of the project

## Model Conventions
Each entity follows a 3-model pattern:
- `EntityName` (e.g., `Dataset`) - Database entity structure
- `EntityNameIn` (e.g., `DatasetIn`) - Creation/form input structure
- `EntityNameView` (e.g., `DatasetView`) - API response structure

## Entity State Management
Each entity has two parts of state:
- Database storage (represented by `EntityName` model)
- Databricks reflection (groups, catalogs, schemas) via `post_create` async function called through FastAPI `background_tasks`

## API Requirements
- All routes in the API app **must** have a `response_model` defined for proper client generation
- Use `background_tasks` for `post_create` operations that sync with Databricks

## Frontend Development Rules

### Routing
- Use `@tanstack/react-router` for all routing
- Main entry point: `src/<project-name>/ui/src/main.tsx`
- Application pages: `src/<project-name>/ui/src/routes/app/` directory

### Component Architecture
Follow this pattern for all pages/components:
1. **Static elements** (forms, buttons, etc.) - render immediately
2. **API data** - fetch using `useXSuspense` hooks
3. **Loading states** - show `Skeleton` components via Suspense fallback
4. **Data rendering** - render once data is fetched

### Data Fetching Rules
- **Always use `useXSuspense` hooks** for API data fetching
- **Always use `Suspense` component** for loading states
- **Always use `Skeleton` component** for loading UI elements
- **Always create new functionality as separate components** in `src/<project-name>/ui/src/components/` directory

### Code Organization
- Keep code clean and maintainable by creating reusable components
- Use the `selector` function with destructuring for clean data access:

```tsx
import {useProfileSuspense} from '@/lib/api';
import {selector} from '@/lib/selector';

const MyComponent = () => {
  const {data: profile} = useProfileSuspense(selector());
  // Use profile directly instead of .data.data
};
```

## Databricks SDK
- For Databricks SDK operations, reference: https://databricks-sdk-py.readthedocs.io/en/latest/
- Use examples from: https://github.com/databricks/databricks-sdk-py/tree/main/examples
- Always check the official documentation for the latest SDK patterns and best practices

## Development Commands
- Frontend client generation: `yarn --cwd ui orval`
- Use `uv` for all Python dependency management
- Use `yarn` for all frontend dependency management

## File Structure Conventions
- Components: `src/<project-name>/ui/src/components/`
- Pages: `src/<project-name>/ui/src/routes/`
- API routes: `src/<project-name>/app/`
- Models: `src/<project-name>/app/models/`

## Best Practices
- Prioritize code reusability through component extraction
- Maintain consistent naming conventions across models
- Ensure all API endpoints have proper response models
- Use proper loading states and error handling
- Follow the established patterns for data fetching and state management 
